/* eslint-disable complexity */
/**
 * Walk ast
 * @param {ASTNode} ast An ast generated by acorn.parse().
 * @param {Function} fn A function called for each ast nodes.
 * @param {Array.<ASTNode>} ancestors An array of ancestor nodes.
 * @returns {undefined}
 */
module.exports = function walk(ast, fn, ancestors = []) {
	if (fn(ast, ancestors.slice())) {
		return;
	}
	if (!ast) {
		return;
	}
	const nextAncestors = ancestors.concat(ast);
	switch (ast.type) {
	case 'Program':
	case 'BlockStatement':
	case 'ClassBody':
		for (const node of ast.body) {
			walk(node, fn, nextAncestors);
		}
		break;
	case 'WhileStatement':
		walk(ast.test, fn, nextAncestors);
		walk(ast.body, fn, nextAncestors);
		break;
	case 'ForOfStatement':
		walk(ast.left, fn, nextAncestors);
		walk(ast.right, fn, nextAncestors);
		walk(ast.body, fn, nextAncestors);
		break;
	case 'ConditionalExpression':
	case 'IfStatement':
		walk(ast.test, fn, nextAncestors);
		walk(ast.consequent, fn, nextAncestors);
		walk(ast.alternate, fn, nextAncestors);
		break;
	case 'SwitchStatement':
		walk(ast.discriminant, fn, nextAncestors);
		for (const node of ast.cases) {
			walk(node, fn, nextAncestors);
		}
		break;
	case 'SwitchCase':
		for (const node of ast.consequent) {
			walk(node, fn, nextAncestors);
		}
		walk(ast.test, fn, nextAncestors);
		break;
	case 'ReturnStatement':
	case 'UnaryExpression':
		walk(ast.argument, fn, nextAncestors);
		break;
	case 'ClassExpression':
	case 'ClassDeclaration':
		walk(ast.id, fn, nextAncestors);
		walk(ast.body, fn, nextAncestors);
		break;
	case 'Property':
	case 'MethodDefinition':
		walk(ast.key, fn, nextAncestors);
		walk(ast.value, fn, nextAncestors);
		break;
	case 'BinaryExpression':
	case 'AssignmentExpression':
	case 'AssignmentPattern':
	case 'LogicalExpression':
		walk(ast.left, fn, nextAncestors);
		walk(ast.right, fn, nextAncestors);
		break;
	case 'ExpressionStatement':
		walk(ast.expression, fn, nextAncestors);
		break;
	case 'MemberExpression':
		walk(ast.object, fn, nextAncestors);
		walk(ast.property, fn, nextAncestors);
		break;
	case 'NewExpression':
	case 'CallExpression':
		walk(ast.callee, fn, nextAncestors);
		for (const node of ast.arguments) {
			walk(node, fn, nextAncestors);
		}
		break;
	case 'VariableDeclaration':
		for (const node of ast.declarations) {
			walk(node, fn, nextAncestors);
		}
		break;
	case 'VariableDeclarator':
		walk(ast.id, fn, nextAncestors);
		walk(ast.init, fn, nextAncestors);
		break;
	case 'FunctionExpression':
	case 'ArrowFunctionExpression':
		walk(ast.id, fn, nextAncestors);
		for (const node of ast.params) {
			walk(node, fn, nextAncestors);
		}
		walk(ast.body, fn, nextAncestors);
		break;
	case 'ObjectPattern':
	case 'ObjectExpression':
		for (const node of ast.properties) {
			walk(node, fn, nextAncestors);
		}
		break;
	case 'ArrayPattern':
	case 'ArrayExpression':
		for (const node of ast.elements) {
			walk(node, fn, nextAncestors);
		}
		break;
	case 'TryStatement':
		walk(ast.block, fn, nextAncestors);
		walk(ast.handler, fn, nextAncestors);
		walk(ast.finalizer, fn, nextAncestors);
		break;
	case 'CatchClause':
		walk(ast.param, fn, nextAncestors);
		walk(ast.body, fn, nextAncestors);
		break;
	case 'ThrowStatement':
		walk(ast.argument, fn, nextAncestors);
		break;
	case 'TemplateLiteral':
		for (const node of ast.expressions) {
			walk(node, fn, nextAncestors);
		}
		for (const node of ast.quasis) {
			walk(node, fn, nextAncestors);
		}
		break;
	case 'TemplateElement':
	case 'BreakStatement':
	case 'ThisExpression':
	case 'Identifier':
	case 'Literal':
		break;
	default:
		throw ast;
	}
};
